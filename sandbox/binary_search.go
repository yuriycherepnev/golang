//// Copyright 2010 The Go Authors. All rights reserved.
//// Use of this source code is governed by a BSD-style
//// license that can be found in the LICENSE file.
//
//// Этот файл реализует двоичный (бинарный) поиск.
//
//package sort
//
//// Search использует двоичный поиск для нахождения и возврата наименьшего индекса i
//// в диапазоне [0, n), при котором f(i) истинно, при условии, что на диапазоне [0, n)
//// f(i) == true влечёт f(i+1) == true. То есть Search требует, чтобы
//// f была ложной для некоторого (возможно, пустого) префикса входного диапазона [0, n),
//// а затем истинной для (возможно, пустого) остатка; Search возвращает
//// первый индекс с истинным значением. Если такого индекса нет, Search возвращает n.
//// (Обратите внимание, что возвращаемое значение "не найдено" равно n, а не -1, как, например,
//// в strings.Index.)
//// Search вызывает f(i) только для i в диапазоне [0, n).
////
//// Обычное использование Search — найти индекс i для значения x в
//// отсортированной, индексируемой структуре данных, такой как массив или срез.
//// В этом случае аргумент f, обычно замыкание (closure), захватывает значение,
//// которое нужно найти, а также то, как индексируется и упорядочивается структура данных.
////
//// Например, для среза data, отсортированного по возрастанию,
//// вызов Search(len(data), func(i int) bool { return data[i] >= 23 })
//// возвращает наименьший индекс i, такой что data[i] >= 23. Если вызывающая сторона
//// хочет проверить, присутствует ли 23 в срезе, она должна отдельно проверить data[i] == 23.
////
//// Для поиска в данных, отсортированных по убыванию, следует использовать оператор <=
//// вместо оператора >=.
////
//// Чтобы завершить пример выше, следующий код пытается найти значение
//// x в целочисленном срезе data, отсортированном по возрастанию:
////
////	x := 23
////	i := sort.Search(len(data), func(i int) bool { return data[i] >= x })
////	if i < len(data) && data[i] == x {
////		// x присутствует на позиции data[i]
////	} else {
////		// x отсутствует в data,
////		// но i — это индекс, куда его можно было бы вставить.
////	}
////
//// В качестве более забавного примера, эта программа угадывает ваше число:
////
////	func GuessingGame() {
////		var s string
////		fmt.Printf("Загадайте целое число от 0 до 100.\n")
////		answer := sort.Search(100, func(i int) bool {
////			fmt.Printf("Ваше число <= %d? ", i)
////			fmt.Scanf("%s", &s)
////			return s != "" && s[0] == 'y'
////		})
////		fmt.Printf("Ваше число — %d.\n", answer)
////	}
//func Search(n int, f func(int) bool) int {
//	// Определим f(-1) == false и f(n) == true.
//	// Инвариант: f(i-1) == false, f(j) == true.
//	i, j := 0, n
//	for i < j {
//		h := int(uint(i+j) >> 1) // избегаем переполнения при вычислении h
//		// i ≤ h < j
//		if !f(h) {
//			i = h + 1 // сохраняет f(i-1) == false
//		} else {
//			j = h // сохраняет f(j) == true
//		}
//	}
//	// i == j, f(i-1) == false, и f(j) (= f(i)) == true  =>  ответ i.
//	return i
//}
//
//// Find использует двоичный поиск для нахождения и возврата наименьшего индекса i в диапазоне [0, n),
//// при котором cmp(i) <= 0. Если такого индекса i нет, Find возвращает i = n.
//// Найденный результат found равен true, если i < n и cmp(i) == 0.
//// Find вызывает cmp(i) только для i в диапазоне [0, n).
////
//// Чтобы разрешить двоичный поиск, Find требует, чтобы cmp(i) > 0 для начального
//// префикса диапазона, cmp(i) == 0 в середине и cmp(i) < 0 для
//// конечного суффикса диапазона. (Каждый поддиапазон может быть пустым.)
//// Обычный способ задать это условие — интерпретировать cmp(i)
//// как сравнение искомого целевого значения t с элементом i в
//// базовой индексированной структуре данных x, возвращая <0, 0 и >0,
//// когда t < x[i], t == x[i] и t > x[i] соответственно.
////
//// Например, чтобы найти конкретную строку в отсортированном списке строк
//// с произвольным доступом:
////
////	i, found := sort.Find(x.Len(), func(i int) int {
////	    return strings.Compare(target, x.At(i))
////	})
////	if found {
////	    fmt.Printf("найдено %s на позиции %d\n", target, i)
////	} else {
////	    fmt.Printf("%s не найдено, можно вставить на позицию %d", target, i)
////	}
//func Find(n int, cmp func(int) int) (i int, found bool) {
//	// Инварианты здесь похожи на инварианты в Search.
//	// Определим cmp(-1) > 0 и cmp(n) <= 0
//	// Инвариант: cmp(i-1) > 0, cmp(j) <= 0
//	i, j := 0, n
//	for i < j {
//		h := int(uint(i+j) >> 1) // избегаем переполнения при вычислении h
//		// i ≤ h < j
//		if cmp(h) > 0 {
//			i = h + 1 // сохраняет cmp(i-1) > 0
//		} else {
//			j = h // сохраняет cmp(j) <= 0
//		}
//	}
//	// i == j, cmp(i-1) > 0 и cmp(j) <= 0
//	return i, i < n && cmp(i) == 0
//}
//
//// Удобные обёртки для распространённых случаев.
//
//// SearchInts ищет x в отсортированном срезе целых чисел и возвращает индекс,
//// как указано в [Search]. Возвращаемое значение — это индекс для вставки x, если x
//// отсутствует (может быть равным len(a)).
//// Срез должен быть отсортирован по возрастанию.
//func SearchInts(a []int, x int) int {
//	return Search(len(a), func(i int) bool { return a[i] >= x })
//}
//
//// SearchFloat64s ищет x в отсортированном срезе чисел float64 и возвращает индекс,
//// как указано в [Search]. Возвращаемое значение — это индекс для вставки x, если x
//// отсутствует (может быть равным len(a)).
//// Срез должен быть отсортирован по возрастанию.
//func SearchFloat64s(a []float64, x float64) int {
//	return Search(len(a), func(i int) bool { return a[i] >= x })
//}
//
//// SearchStrings ищет x в отсортированном срезе строк и возвращает индекс,
//// как указано в Search. Возвращаемое значение — это индекс для вставки x, если x
//// отсутствует (может быть равным len(a)).
//// Срез должен быть отсортирован по возрастанию.
//func SearchStrings(a []string, x string) int {
//	return Search(len(a), func(i int) bool { return a[i] >= x })
//}
//
//// Search возвращает результат применения [SearchInts] к получателю и x.
//func (p IntSlice) Search(x int) int { return SearchInts(p, x) }
//
//// Search возвращает результат применения [SearchFloat64s] к получателю и x.
//func (p Float64Slice) Search(x float64) int { return SearchFloat64s(p, x) }
//
//// Search возвращает результат применения [SearchStrings] к получателю и x.
//func (p StringSlice) Search(x string) int { return SearchStrings(p, x) }
